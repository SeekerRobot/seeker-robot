# Seeker Robot

A ROS 2 Jazzy robotics project with ESP32 microcontrollers communicating via micro-ROS. The entire development environment runs inside Docker.

## AI Disclosure

This file was generated by AI, and was double checked for any errors (as of 2/9/26);

## Architecture

The project spans two workspaces:

```
seeker-robot/
├── ros2_ws/          # ROS 2 colcon workspace (high-level autonomy)
│   └── src/
│       ├── mcu_msgs/     # Shared message/service definitions (.msg/.srv)
│       └── ...           # Other ROS 2 packages
├── mcu_ws/           # PlatformIO workspace (ESP32 firmware)
│   ├── src/              # Firmware source code
│   ├── extra_packages/   # mcu_msgs symlink (auto-mounted by Docker)
│   ├── libs_external/    # Vendored micro-ROS PlatformIO library
│   └── platformio.ini    # Build config (C++17, serial transport)
└── docker/           # Containerized dev environment
    ├── Dockerfile            # Multi-stage: base → dev/prod
    ├── Dockerfile.init-bootstrap
    ├── docker-compose.yml
    └── .env.example
```

**How micro-ROS bridges the two workspaces:** The `mcu_msgs` package in `ros2_ws/src/mcu_msgs/` defines the ROS 2 message and service types shared between the ROS 2 nodes and the ESP32 firmware. Docker Compose bind-mounts this same directory into `mcu_ws/extra_packages/mcu_msgs` so the micro-ROS build can compile the same interface definitions into the firmware. At runtime, the micro-ROS agent (pre-built in the Docker image) bridges serial communication between the ESP32 and the ROS 2 graph.

## Prerequisites

Install the following on your host machine:

| Tool | Link | Notes |
|------|------|-------|
| **Git** | [git-scm.com](https://git-scm.com/) | Required for cloning the repo |
| **Docker Desktop** | [docker.com](https://www.docker.com/products/docker-desktop/) | Runs the development container |
| **VSCode** | [code.visualstudio.com](https://code.visualstudio.com/) | Recommended editor |
| **X Server** (for GUI apps) | See [X11 Setup](#x11-server-setup) below | Required for Gazebo, RViz, rqt |

### VSCode Extensions (Recommended)

- [Dev Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) — attach to the running container
- [Docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker) — manage containers from the sidebar
- [C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) — IntelliSense and debugging

## Getting Started

### 1. Clone the Repository

```bash
git clone --recurse-submodules https://github.com/seeker-robot/seeker-robot.git
cd seeker-robot
```

### 2. Configure Environment Variables

```bash
cp docker/.env.example docker/.env
```

Open `docker/.env` and configure:

- **`BUILD_TARGET`** — Choose which Docker stage to build:
  - `dev` — Includes Gazebo Harmonic, RViz, rqt, and GDB. Use this on your PC/laptop for simulation and visualization.
  - `prod` — Minimal runtime only. No GUI tools. Use this on the robot or for headless CI.
- **Display / Network** — Uncomment the block matching your OS (see the comments in the file).

### 3. X11 Server Setup

GUI applications (Gazebo, RViz, rqt) require an X server on your host.

#### Windows — VcXsrv

1. Install [VcXsrv](https://sourceforge.net/projects/vcxsrv/).
2. Launch **XLaunch** with these settings:
   - Multiple windows
   - Start no client
   - **Check** "Disable access control"
3. In `docker/.env`, use:
   ```
   DISPLAY_CONFIG=host.docker.internal:0
   NETWORK_MODE_CONFIG=bridge
   ```

#### macOS — XQuartz

1. Install [XQuartz](https://www.xquartz.org/) (`brew install --cask xquartz`).
2. Open XQuartz, go to **Preferences > Security**, and check "Allow connections from network clients".
3. Log out and back in, then run `xhost +localhost`.
4. In `docker/.env`, use:
   ```
   DISPLAY_CONFIG=host.docker.internal:0
   NETWORK_MODE_CONFIG=bridge
   ```

#### Linux — Native X11

No extra software needed. In `docker/.env`, use:
```
DISPLAY_CONFIG=${DISPLAY}
NETWORK_MODE_CONFIG=host
```

### 4. Build and Start the Containers

```bash
cd docker

# Build images (first time or after Dockerfile changes)
docker compose build

# Initialize volumes (seeds libs_external, fixes permissions)
docker compose up init-bootstrap

# Start the dev container in the background
docker compose up -d ros2
```

> **Note:** The `init-bootstrap` service is a one-shot container that sets correct ownership on named volumes and copies the vendored micro-ROS library into the `mcu_lib_external` volume. It only needs to run once (or when volumes are recreated).

### 5. Enter the Container

**Option A — CLI:**

```bash
docker compose exec ros2 bash
```

**Option B — VSCode (Dev Containers extension):**

1. Open the Docker sidebar in VSCode.
2. Right-click the running `ros2` container and select **Attach Visual Studio Code**.
3. VSCode reopens inside the container with full IntelliSense and terminal access.

## Building

All build commands run **inside the container**.

### ROS 2 Packages

```bash
cd ~/ros2_workspaces

# Build all packages
colcon build

# Source the workspace (already in .bashrc, but needed after fresh builds)
source install/setup.bash

# Build a single package
colcon build --packages-select mcu_msgs

# Run tests
colcon test
colcon test-result --verbose
```

### MCU Firmware (PlatformIO)

```bash
cd ~/mcu_workspaces/seeker_mcu

# Build the default environment
pio run

# Flash via serial (requires USB passthrough — see below)
pio run -t upload
```

### Rebuilding After Message Changes

Since `mcu_msgs` is shared between both workspaces, changes to `.msg` or `.srv` files require rebuilding on both sides:

```bash
# 1. Rebuild the ROS 2 package
cd ~/ros2_workspaces
colcon build --packages-select mcu_msgs
source install/setup.bash

# 2. Rebuild the MCU firmware (picks up changes via extra_packages mount)
cd ~/mcu_workspaces/seeker_mcu
pio run
```

## USB Passthrough (Flashing ESP32)

To flash an ESP32 from inside the Docker container on Windows, you need to forward the USB device using `usbipd`:

1. Install [usbipd-win](https://github.com/dorssel/usbipd-win/releases).
2. Plug in your ESP32. Find its bus ID:
   ```powershell
   usbipd list
   ```
3. Bind and attach the device to WSL/Docker:
   ```powershell
   usbipd bind --busid <BUS_ID>
   usbipd attach --wsl --busid <BUS_ID>
   ```
4. Inside the container, the device appears at `/dev/ttyUSB0` or `/dev/ttyACM0`. Flash with:
   ```bash
   pio run -t upload --upload-port /dev/ttyUSB0
   ```

> On Linux, the `/dev` directory is bind-mounted directly into the container, so USB devices are available without extra setup. On macOS, USB passthrough is not natively supported by Docker Desktop.

## Running the micro-ROS Agent

The micro-ROS agent bridges serial communication between the ESP32 and the ROS 2 graph. Inside the container:

```bash
ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyUSB0
```

This listens on the serial port and exposes the ESP32's topics/services to the rest of the ROS 2 network.

## IntelliSense

For the best C++ IntelliSense experience, **work inside the dev container** using VSCode's Dev Containers extension. The container has all ROS 2 headers, micro-ROS libraries, and build tools installed.

A `ros2_ws/.vscode/c_cpp_properties.json` is included in the repository and is bind-mounted into the container at `~/ros2_workspaces/.vscode/`. It configures include paths for `/opt/ros/jazzy/`, the workspace install directory, and system headers.

## Volume Layout (Inside Container)

| Host Path | Container Path | Type |
|-----------|---------------|------|
| `ros2_ws/src/` | `~/ros2_workspaces/src/seeker_ros/` | Bind mount |
| `ros2_ws/.vscode/` | `~/ros2_workspaces/.vscode/` | Bind mount |
| `mcu_ws/` | `~/mcu_workspaces/seeker_mcu/` | Bind mount |
| `ros2_ws/src/mcu_msgs/` | `~/mcu_workspaces/seeker_mcu/extra_packages/mcu_msgs/` | Bind mount |
| Named volumes | `~/ros2_workspaces/{build,install,log}` | Docker volume |
| Named volume | `~/.platformio` | Docker volume |
| Named volume | `~/mcu_workspaces/seeker_mcu/.pio` | Docker volume |
| Named volume | `~/mcu_workspaces/seeker_mcu/libs_external` | Docker volume |

Build artifacts are stored in named Docker volumes to avoid polluting the host filesystem and to improve I/O performance on Windows/macOS.

## AI Disclosure

This project was developed with assistance of AI-powered code generation tools. The contributors and maintainers have and shall be clear (to a reasonable extent) about what files have AI-generated code and how AI-generated code was used in them.
